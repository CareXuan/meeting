# 面试问题总结

1. 操作系统对系统进程如何进行存储调度
	1. 存储
	2. 调度
	
2. MySQL唯一索引和普通索引的区别
两种索引查询能力没有差别，在性能上有差距。
	1. 查询时
	    普通索引查到第一个满足条件的记录后继续向后遍历，知道第一个不满足条件的记录。
	    唯一索引因为定义了唯一性，查到第一个满足条件的记录后就会停止搜索。
	    虽然在普通索引查到后会再向后检索一次，但是InnoDB的数据是按照数据页为单位进行读写，不是从磁盘读取记录，是先把数据页读到内存中进行检索。对CPU消耗基本可以忽略。所以在查询方面普通索引和唯一索引没有明显区别。
	2. 更新时
	    普通索引将数据页读入内存更新数据页
	    唯一索引将数据页读入内存，判断是否唯一，再更新数据页
	    因为存在change buffer的机制降低了普通索引更新的IO操作，而唯一索引是不能用change buffer的，所以普通索引在更新时性能高于唯一索引。
	    如果业务能够保证数据唯一性的情况下普通索引优于唯一索引。
	
3. MySQL中使用B树的索引
    MySQL中使用InnoDB的情况下索引默认是B+树，可以针对性进行设置。
    
4. 应用层常用协议
	- DNS 域名解析
	- HTTP 超文本传输
	- FTP 传文件的
	- SMTP 传邮件的
	- SNMP 简单网络管理
	- Talnet 远程登录
	
5. 网络层常用协议
	- IP 网络协议
	- ICMP 网络控制信息协议
	  目的主机必须返回ICMP会送应答消息给源主机，如果源主机在一定时间内收到应答，则认为目的主机可达（ping命令）
	- ARP 地址解析
	  每一台主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器IP地址到硬件地址的映射表。
	- RARP 逆地址解析
	
6. 传输层常用协议
	- TCP
		- TCP的三次握手和四次挥手
		1. 为什么要三次握手和四次挥手？
		    TCP协议是一个面向连接的协议，那么在传输数据之前，必须要创建坚实可靠的连接，而一次TCP连接必须要经历三次“对话”才能建立连接，而断开连接则需要四次“对话”才能断开。
		2. 三次握手
		    如果想要建立可靠的连接，那么要求就是连接双方都对连接这件事清楚明白，那么就要双方进行三次“对话”。
		    第一次对话：A会发给B一个同步序列号（SYN），告诉B我要请求你了，并且你可以根据这个序列号回应我
		    第二次对话：B接到请求后用一个带着确认应答（ACK）和SYN的东西回应A，告诉A我收到你的请求了，可以连接，你可以用这个序列号告诉我什么时候要连接
		    第三次对话：A收到B的应答信息后，在发送给B一个带有ACK的东西，告诉B我知道你同意了，我现在要建立连接了
		    至此握手完成，双方建立起连接，开始传输数据
		3. 三次握手如果失败怎么处理
		  - 等待超时
		    发送请求并等待一段时间，如果在等待时间内得到结果立刻返回，如果未得到结果则返回默认结果。
		  - 超时后，服务端向客户端发送RTS报文并进入关闭状态
		    在第三次握手失败的时候接收方服务器不会重传SYN/ACK报文，而是传RTS报文，将连接信息全部初始化，如果收到了RTS位数据为1还想建立连接的话必须从第一次握手开始重新做。
		4. 四次挥手
		    断开连接的时候同样要双方都清楚明白断开连接，所以需要四次“对话”
		    第一次对话：A发送一个控制位FIN给B，告诉B我要断开连接了
		    第二次对话：B回应给A一个ACK，告诉A我知道你要断开了
		    第三次对话：B发送给A一个控制位FIN，告诉A我也要断开连接了
		    第四次对话：A发送给B一个ACK，告诉B我也知道你要断开连接了
		    至此双方都清楚互相要断开连接，连接断开
		5. 四次挥手失败怎么处理
		    第四次挥手失败也就是最后A没有传个B一个ACK，那么TCP会首先认为是因为B没有成功的发给A一个FIN，会重发一个FIN，并设置一个定时器，如果此时A已经关闭了，就永远无法收到这个FIN，B也就永远无法收到ACK，但B还在等待状态，就会不断地进行探查，如果所有探查都没有收到回应，B就认为A已经关闭了，B也会关闭，终止连接。
	- UDP
	  如果说TCP是连接的协议，那么UDP就是一个非连接的协议，传输数据的时候并不进行源端和终端的连接，只是单纯的抓取应用程序产生的数据，并且尽可能块的把它扔到网络上。并且把每个消息段放到一个队列中，应用程序每次从这个队列中读一个消息段。
	  不建立连接，不维护连接状态，所以不像TCP只能一对一，UDP可以实现一台服务机给多台客户机传输相同的消息。
	  吞吐量不受控制算法调节，只受生成数据的速率，带宽，发送和接收方机器性能影响。
	  尽最大努力交付但不保证可靠交付。
	  UDP不能保证数据的顺序。
	  UDP的信息包只有8字节，而TCP有20字节，UDP占用资源更少。
	  我们常用的ping原理就是向对方主机发送UDP包，对方收到UDP包后将确认收到的消息反馈回来，如果得到及时反馈，则网络是通的。ping命令中就用到了网络层的IP协议和ICMP协议。
	
7. HTTP请求整个过程
	1. 浏览器根据域名解析ip地址找到服务器
	2. 浏览器和服务器建立TCP连接（三次握手）
	3. 浏览器发给服务器一个HTTP请求
	4. 服务器响应HTTP请求，返回给浏览器HTML代码
	5. 浏览器解析HTML代码，并下载静态资源
	6. 关闭TCP连接（四次挥手），并对页面进行渲染
	
8. 哈希表，go如何解决哈希冲突
当关键字值域远大于哈希表长度，而且事先并不知道关键字具体取值就会出现冲突。
	1. 开放定址法（再散列法）
	    当通过一个哈希函数做哈希产生冲突时，如p=H（i），p发生冲突时，基于p再进行哈希算出p1，如果p1依然有冲突就再计算p2，直到不冲突为止。
	2. 拉链法
	    将具有相同哈希值的元素都拼入同一个key中，形成一个同义词单链表
	3. 二次哈希
	    同时构造多个不同的哈希函数，在一个哈希函数出现冲突时换一种哈希函数进行计算，直到冲突不再产生。
	4. 建立公共溢出区
	    将哈希表分为基本表和溢出表，凡是冲突的元素一律填入溢出表。
	
9. B树、B+树
    B树是一颗变种二叉树，对于树上的每一个节点都存成键值对形式，对于一个节点，他的左邻节点和左子节点索引值一定比他小，右邻节点和右子节点索引值一定比他大。
    B+树是B树的进阶版，B+树只有最底层根节点保存数据，其他节点均为索引值，不带有对应数据。对于一个节点他的左邻节点和左子节点索引值一定比他小，右邻节点索引值一定比他大，右子节点的第一个节点的索引值一定是他自己。
  
10. CGI、FastCGI、PHP-FPM的区别
	1. CGI
	    CGI是web服务器和外部应用程序之间传递信息的接口标准。我们一般提到的CGI是实现了CGI接口标准的程序，本质上的CGI就是规定客户端请求数据的时候需要传哪些数据、以什么样的格式传的协议。
	2. FastCGI
	    FastCGI是一种进程的管理工具，在内存中管理CGI进程，与语言无关，主要是为了将CGI解释器保持在内存中并且因此获得高效的性能。
	3. PHP-FPM
	    PHP-FPM就是php中的FastCGI进程管理器，等于对FastCGI再做一层封装，形成了一个专供PHP使用的FastCGI程序。
	
11. 孤儿进程、僵尸进程

12. 物理内存、虚拟内存

13. 非聚簇索引回表查询

      回表查询最明显的例子是一条sql语句，select username from user where id = 10;

      在这条语句中如果username和id都是索引列，那么查询过程就要先根据id进行查询，查询到username对应的索引值，再用这个索引值去二次查询username字段。

      这个操作就叫做回表查询。

14. 什么时候不能命中索引

      1. 条件中有or的时候所有索引都失效，想用or还想用索引那就要在每列上都加上索引，用like 并以%结尾
      2. 联合索引不尊崇最左前缀
      3. like以%开头
      4. 字符串不用引号括起来
      5. 范围查询后，但是范围查询能命中
      6. 查询时条件进行运算
      7. not和!=操作
      8. B树索引中的is null

15. 100个球我先拿，一人只能拿1~5个，怎么拿能保证最后一定我拿完（博弈问题）

      6的倍数都是后手赢，所以先拿4个，让100个球变成96个，形成6的倍数，就稳定后手赢。